<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Injera Be Wat ‚Äî Prototype</title>

  <style>
    :root{
      --bg:#071018;
      --panel:rgba(10,18,30,.78);
      --panel2:rgba(9,16,26,.60);
      --border:rgba(255,255,255,.10);
      --text:#eaf3ff;
      --muted:#b9c7e8;

      /* Ethiopian holiday palette */
      --eth-green:#0f7a3a;
      --eth-yellow:#ffd166;
      --eth-red:#d62828;
      --eth-blue:#1d4ed8;
      --gold:#f7d36a;

      --shadow: 0 18px 60px rgba(0,0,0,.55);
      --r: 18px;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      background:
        radial-gradient(900px 600px at 10% 10%, rgba(15,122,58,.22), transparent 60%),
        radial-gradient(900px 600px at 90% 20%, rgba(214,40,40,.20), transparent 55%),
        radial-gradient(900px 600px at 55% 90%, rgba(255,209,102,.18), transparent 60%),
        linear-gradient(180deg, #06111a, #040810 55%, #02040a);
      min-height:100vh;
      padding:22px;
    }

    .wrap{max-width:1200px;margin:0 auto;display:grid;gap:16px}
    header{
      padding:18px 20px;
      border:1px solid var(--border);
      border-radius:22px;
      background:
        radial-gradient(700px 200px at 20% 20%, rgba(29,78,216,.14), transparent 60%),
        radial-gradient(700px 240px at 80% 20%, rgba(247,211,106,.10), transparent 60%),
        linear-gradient(135deg, rgba(10,18,30,.88), rgba(6,12,20,.72));
      box-shadow: var(--shadow);
    }
    h1{margin:0;font-size:44px;letter-spacing:.3px}
    .sub{margin:6px 0 0;color:var(--muted);line-height:1.35}

    .grid{
      display:grid;
      grid-template-columns: 1.3fr .9fr;
      gap:16px;
      align-items:start;
    }

    .panel{
      border:1px solid var(--border);
      border-radius: var(--r);
      background: linear-gradient(135deg, var(--panel), var(--panel2));
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .panel .hd{
      padding:14px 16px;
      border-bottom:1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .panel .bd{padding:16px}

    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:7px 10px;
      border:1px solid var(--border);
      border-radius:999px;
      color:var(--muted);
      background: rgba(0,0,0,.18);
      font-size:13px;
      white-space:nowrap;
    }
    .pill b{color:var(--text)}

    .row{display:flex;gap:14px;flex-wrap:wrap;align-items:flex-start}
    .row.center{align-items:center}

    /* NEW: stable play layout so Middle never "disappears" */
    .playArea{
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:18px;
      align-items:start;
    }
    .leftCol{min-width:320px}
    .rightCol{min-width:280px}

    /* Circle button */
    .circleBtn{
      width:160px;height:210px;
      border-radius:22px;
      border:1px solid rgba(255,255,255,.16);
      position:relative;
      overflow:hidden;
      cursor:pointer;
      box-shadow: 0 18px 50px rgba(0,0,0,.55);
      background:
        linear-gradient(180deg, rgba(255,255,255,.10), transparent 40%),
        linear-gradient(90deg, rgba(15,122,58,.85), rgba(255,209,102,.85), rgba(214,40,40,.85));
      user-select:none;
    }
    .circleBtn:before{
      content:"";
      position:absolute;inset:-40px;
      background:
        radial-gradient(circle at 30% 30%, rgba(247,211,106,.55), transparent 60%),
        radial-gradient(circle at 70% 70%, rgba(29,78,216,.45), transparent 65%);
      transform: rotate(12deg);
      opacity:.8;
    }
    .circleBtn:after{
      content:"";
      position:absolute;inset:12px;
      border-radius:18px;
      border:2px solid rgba(255,255,255,.22);
      box-shadow: inset 0 0 0 2px rgba(0,0,0,.15);
    }
    .circleBtn .label{
      position:absolute;left:0;right:0;top:0;bottom:0;
      display:grid;
      place-items:center;
      font-weight:900;
      letter-spacing:1px;
      font-size:24px;
      text-transform:uppercase;
      text-shadow: 0 10px 30px rgba(0,0,0,.55);
    }
    .circleBtn .mini{
      position:absolute;left:12px;top:12px;
      padding:6px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.20);
      font-size:12px;color:var(--muted);
    }
    .circleBtn.disabled{opacity:.45;cursor:not-allowed;filter:grayscale(.2)}
    .circleBtn:hover:not(.disabled){transform: translateY(-1px);}

    /* Card UI */
    .card{
      width:96px;height:132px;
      border-radius:16px;
      position:relative;
      cursor:pointer;
      border:1px solid rgba(255,255,255,.18);
      box-shadow: 0 16px 40px rgba(0,0,0,.40);
      overflow:hidden;
      background:
        linear-gradient(180deg, rgba(255,255,255,.12), transparent 35%),
        radial-gradient(120px 120px at 20% 20%, rgba(247,211,106,.35), transparent 60%),
        radial-gradient(140px 140px at 80% 80%, rgba(29,78,216,.25), transparent 62%),
        linear-gradient(135deg, rgba(255,255,255,.92), rgba(255,255,255,.78));
      color:#0a0f16;
      user-select:none;
    }
    .card:before{
      content:"";
      position:absolute;left:0;top:0;right:0;height:18px;
      background: linear-gradient(90deg, var(--eth-green), var(--eth-yellow), var(--eth-red));
      opacity:.95;
    }
    .card:after{
      content:"";
      position:absolute;inset:0;
      background:
        radial-gradient(circle at 50% 58%, rgba(214,40,40,.10), transparent 55%),
        repeating-linear-gradient(45deg, rgba(15,122,58,.08), rgba(15,122,58,.08) 6px, rgba(255,209,102,.08) 6px, rgba(255,209,102,.08) 12px);
      mix-blend-mode:multiply;
      opacity:.55;
      pointer-events:none;
    }
    .card .rank{
      position:absolute;left:10px;top:26px;
      font-size:30px;
      font-weight:900;
      letter-spacing:.5px;
      text-shadow: 0 2px 0 rgba(255,255,255,.35);
    }
    .card .corner{
      position:absolute;right:10px;bottom:10px;
      font-size:14px;
      font-weight:800;
      opacity:.85;
    }
    .card.selected{
      outline:3px solid rgba(247,211,106,.75);
      transform: translateY(-2px);
      box-shadow: 0 20px 60px rgba(0,0,0,.55);
    }

    .zoneTitle{
      font-size:18px;
      font-weight:900;
      margin:0 0 10px;
    }

    .pickedWrap{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:14px;
    }
    .pickedSlot{
      height:140px;
      border-radius:18px;
      border:1px dashed rgba(255,255,255,.22);
      display:grid;
      place-items:center;
      background: rgba(0,0,0,.18);
      color:var(--muted);
      position:relative;
      overflow:hidden;
    }
    .pickedSlot .hint{
      font-size:12px;
      opacity:.8;
      padding:10px;
      text-align:center;
      line-height:1.25;
    }

    .controls{
      display:flex;flex-wrap:wrap;gap:10px;align-items:center;
      margin-top:10px;
    }
    button{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);
      color: var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:800;
      letter-spacing:.2px;
    }
    button:hover{filter:brightness(1.05)}
    button.primary{
      background: linear-gradient(135deg, rgba(15,122,58,.55), rgba(255,209,102,.22));
      border-color: rgba(124,255,178,.25);
    }
    button.danger{
      background: linear-gradient(135deg, rgba(214,40,40,.42), rgba(255,111,177,.18));
      border-color: rgba(255,111,177,.25);
    }
    button:disabled{opacity:.45;cursor:not-allowed;filter:grayscale(.2);}

    .log{
      height:330px;
      overflow:auto;
      padding-right:6px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .logItem{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      border-radius:14px;
      padding:10px 12px;
      color:var(--muted);
      line-height:1.35;
      font-size:13px;
    }
    .logItem strong{color:var(--text)}
    .small{font-size:12px;color:var(--muted)}
    .statRow{display:flex;gap:10px;flex-wrap:wrap}
    .stat{border:1px solid rgba(255,255,255,.10); background: rgba(0,0,0,.18); border-radius:14px; padding:10px 12px; min-width:200px; flex:1}
    .stat .name{font-weight:900}
    .stat .meta{font-size:13px;color:var(--muted);margin-top:4px}
    .rightTop{display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end}

    /* Setup overlay */
    .overlay{position:fixed; inset:0;background: rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;padding:20px;z-index:50;}
    .overlay.show{display:flex;}
    .modal{
      width:min(720px, 100%);
      border:1px solid var(--border);
      border-radius:22px;
      background: linear-gradient(135deg, rgba(10,18,30,.92), rgba(6,12,20,.86));
      box-shadow: var(--shadow);
      padding:18px;
    }
    .modal h2{margin:0 0 8px;font-size:22px}
    .modal p{margin:6px 0;color:var(--muted);line-height:1.35}
    .formRow{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
    .field{flex:1;min-width:160px}
    label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
    input, select{
      width:100%;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.25);
      color: var(--text);
      outline:none;
    }
    .modal .actions{display:flex;gap:10px;justify-content:flex-end;margin-top:14px;flex-wrap:wrap}

    @media (max-width: 980px){
      .grid{grid-template-columns:1fr}
      .log{height:260px}
      .playArea{grid-template-columns:1fr}
      .leftCol,.rightCol{min-width:unset}
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <h1>Injera Be Wat</h1>
      <div class="sub">
        <b>Setup:</b> Each player draws <b>1 starter card</b> (auto‚Äëbanked). If a <b>Joker</b> is drawn during setup, it goes back into the Circle randomly and you draw again.<br/>
        Then seed the Middle with <b>3 cards</b> (Jokers also go back randomly during seeding).<br/>
        <b>Play:</b> Pick from the Circle. Capture from Middle by <b>MATCH</b> or <b>ADD</b> (2+ cards sum to picked value). If you capture, you <b>pick again</b> and your turn continues.<br/>
        <b>End:</b> When the last Circle card is picked, the last picker takes any remaining Middle cards, then score (numbers 1pt, faces 10pts, Joker 1pt).
      </div>
    </header>

    <div class="grid">
      <!-- MAIN -->
      <section class="panel">
        <div class="hd">
          <div class="pill"><b>Turn:</b> <span id="turnName"></span></div>
          <div class="pill"><b>Phase:</b> <span id="phaseName"></span></div>
          <div class="rightTop">
            <div class="pill">Circle: <b id="deckCount"></b></div>
            <div class="pill">Middle: <b id="midCount"></b></div>
            <div class="pill">Selected sum: <b id="selSum">0</b></div>
          </div>
        </div>

        <div class="bd">
          <div class="playArea">
            <div class="leftCol">
              <div class="zoneTitle">Circle</div>
              <div id="circleBtn" class="circleBtn">
                <div class="mini">draw</div>
                <div class="label">PICK</div>
              </div>
              <div class="small" id="circleHint" style="margin-top:8px;">Click the Circle to draw 1 card.</div>

              <div class="pickedWrap">
                <div class="zoneTitle">Picked</div>
                <div class="pickedSlot" id="pickedSlot">
                  <div class="hint">No picked card yet.</div>
                </div>

                <div class="controls">
                  <button id="btnMatch" disabled>CAPTURE (MATCH)</button>
                  <button id="btnAdd" disabled>CAPTURE (ADD)</button>
                  <button id="btnClear" disabled>CLEAR</button>
                  <button id="btnEnd" class="danger" disabled>END TURN</button>
                  <button id="btnNew" class="primary">NEW GAME</button>
                </div>

                <div class="small" id="tip" style="margin-top:6px;">
                  Tip: After a successful capture, pick again (same turn).
                </div>
              </div>
            </div>

            <div class="rightCol">
              <div class="zoneTitle">Middle (tap cards to select)</div>
              <div class="row" id="middleRow" style="gap:12px;flex-wrap:wrap;"></div>
            </div>
          </div>
        </div>
      </section>

      <!-- RIGHT -->
      <aside class="panel">
        <div class="hd">
          <div style="font-weight:900;font-size:18px;">Players</div>
          <div class="pill">Score counts at end</div>
        </div>
        <div class="bd">
          <div class="statRow" id="playersBox"></div>

          <div style="margin-top:14px;font-weight:900;font-size:18px;">Log</div>
          <div class="log" id="log"></div>
        </div>
      </aside>
    </div>
  </div>

  <!-- Setup overlay -->
  <div class="overlay" id="setupOverlay" aria-hidden="true">
    <div class="modal">
      <h2>New Game Setup</h2>
      <p>Pick number of players and names. (You can leave names blank; defaults will be used.)</p>
      <div class="formRow">
        <div class="field" style="max-width:220px;">
          <label for="playerCount">Players</label>
          <select id="playerCount">
            <option value="2">2 players</option>
            <option value="3" selected>3 players</option>
            <option value="4">4 players</option>
          </select>
        </div>
      </div>
      <div class="formRow" id="nameFields"></div>
      <div class="actions">
        <button id="btnCancelSetup">Cancel</button>
        <button id="btnStartSetup" class="primary">Start Game</button>
      </div>
    </div>
  </div>

  <script>
    const $ = (id)=>document.getElementById(id);
    const suits = ["‚ô†","‚ô•","‚ô¶","‚ô£"];
    const PHASE = { SETUP_STARTERS:"SETUP (STARTERS)", SETUP_MIDDLE:"SETUP (SEED MIDDLE)", PLAY:"PLAY", ENDED:"ENDED" };

    function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }
    function randomInsertBack(deck, card){ const idx=Math.floor(Math.random()*(deck.length+1)); deck.splice(idx,0,card); }
    function isNumericCard(card){ return card.rank==="A" || (typeof card.rank==="number" && card.rank>=2 && card.rank<=10); }
    function addValue(card){ if(card.rank==="A") return 1; if(typeof card.rank==="number") return card.rank; if(card.type==="face") return 10; if(card.type==="joker") return 1; return 0; }
    function scoreCard(card){ if(card.type==="joker") return 1; if(card.type==="face") return 10; return 1; }
    function totalPoints(pile){ return pile.reduce((s,c)=>s+scoreCard(c),0); }

    let state;

    function newDeck(){
      const deck=[];
      for(const s of suits){
        deck.push({rank:"A", suit:s, type:"num", id:crypto.randomUUID()});
        for(let n=2;n<=10;n++) deck.push({rank:n, suit:s, type:"num", id:crypto.randomUUID()});
        ["J","Q","K"].forEach(r=> deck.push({rank:r, suit:s, type:"face", id:crypto.randomUUID()}));
      }
      deck.push({rank:"JOKER", suit:"", type:"joker", id:crypto.randomUUID()});
      deck.push({rank:"JOKER", suit:"", type:"joker", id:crypto.randomUUID()});
      return shuffle(deck);
    }

    function initGame(players){
      state = {
        players: players.map(name => ({name, pile:[]})),
        turn: 0,
        deck: newDeck(),
        middle: [],
        picked: null,
        capturedThisTurn: false,
        selectedIds: new Set(),
        phase: PHASE.SETUP_STARTERS,
        setupStarterIndex: 0,
        setupMiddleTarget: 3,
        lastPickTriggered: false,
        lastPickerIndex: null,
        lastDraw: null
      };
      logClear();
      logMsg(`New game started. <strong>${state.players.length}</strong> players.`);
      logMsg(`Setup: each player draws <strong>1 starter</strong> (auto‚Äëbanked).`);
      render();
    }

    function cardLabel(card){ return (card.type==="joker") ? "JOKER" : `${card.rank}${card.suit}`; }

    function renderCard(card, {selected=false}={}){
      const div=document.createElement("div");
      div.className="card"+(selected?" selected":"");
      div.dataset.id=card.id;

      const rank=document.createElement("div");
      rank.className="rank";
      rank.textContent=(card.type==="joker") ? "‚òÖ" : card.rank;
      div.appendChild(rank);

      const corner=document.createElement("div");
      corner.className="corner";
      corner.textContent=(card.type==="joker") ? "JOKER" : card.suit;
      div.appendChild(corner);
      return div;
    }

    function currentPlayer(){ return state.players[state.turn]; }
    function advanceTurn(){ state.turn = (state.turn+1) % state.players.length; }

    function render(){
      $("turnName").textContent = state.players[state.turn]?.name ?? "-";
      $("phaseName").textContent = state.phase;
      $("deckCount").textContent = state.deck.length;
      $("midCount").textContent = state.middle.length;

      const circle=$("circleBtn");
      const circleDisabled = (state.phase===PHASE.ENDED) || (state.phase===PHASE.PLAY && !!state.picked && !state.capturedThisTurn);
      circle.classList.toggle("disabled", circleDisabled);

      const hint=$("circleHint");
      if(state.phase===PHASE.SETUP_STARTERS) hint.textContent=`Setup: ${state.players[state.setupStarterIndex].name} draw a starter card.`;
      else if(state.phase===PHASE.SETUP_MIDDLE) hint.textContent=`Setup: Seed the Middle (${state.middle.length}/${state.setupMiddleTarget}).`;
      else if(state.phase===PHASE.PLAY) hint.textContent = state.picked ? (state.capturedThisTurn ? "You captured! You can CAPTURE again with the same picked card, or click the Circle to PICK again (same turn)." : "Select Middle cards, then CAPTURE ‚Äî or END TURN if you miss it.") : "Click the Circle to draw 1 card.";
      else hint.textContent="Game over. Start a new game to play again.";

      // Picked Slot
      const slot=$("pickedSlot"); slot.innerHTML="";
      if(state.picked){
        slot.appendChild(renderCard(state.picked,{selected:false}));
      } else if(state.phase!==PHASE.PLAY && state.lastDraw){
        slot.appendChild(renderCard(state.lastDraw,{selected:false}));
        const h=document.createElement("div"); h.className="hint"; h.innerHTML="<small>Setup draw</small>"; slot.appendChild(h);
      } else {
        const h=document.createElement("div"); h.className="hint"; h.textContent="No picked card yet."; slot.appendChild(h);
      }

      // Middle cards ALWAYS render (never hidden)
      const mid=$("middleRow"); mid.innerHTML="";
      state.middle.forEach(c=>{
        const selected=state.selectedIds.has(c.id);
        const node=renderCard(c,{selected});
        node.addEventListener("click", ()=>{
          if(state.phase!==PHASE.PLAY) return;
          if(!state.picked) return;
          if(state.selectedIds.has(c.id)) state.selectedIds.delete(c.id);
          else state.selectedIds.add(c.id);
          updateSelectionUI();
          node.classList.toggle("selected", state.selectedIds.has(c.id));
        });
        mid.appendChild(node);
      });

      // Players box
      const pbox=$("playersBox"); pbox.innerHTML="";
      state.players.forEach((p,idx)=>{
        const card=document.createElement("div");
        card.className="stat";
        const pts=totalPoints(p.pile);
        card.innerHTML = `
          <div class="name">${idx===state.turn && state.phase!==PHASE.ENDED ? "‚ñ∂ " : ""}${p.name}</div>
          <div class="meta">Cards collected: <b>${p.pile.length}</b></div>
          <div class="meta">Points (if ended now): <b>${pts}</b></div>
        `;
        pbox.appendChild(card);
      });

      updateSelectionUI();
    }

    function updateSelectionUI(){
      const selectedCards = state.middle.filter(c=>state.selectedIds.has(c.id));
      let sum=0; selectedCards.forEach(c=> sum += addValue(c));
      $("selSum").textContent = sum;

      const hasPicked = !!state.picked && state.phase===PHASE.PLAY;
      $("btnClear").disabled = !hasPicked || state.selectedIds.size===0;
      $("btnMatch").disabled = !hasPicked || state.selectedIds.size===0;

      const canAdd = hasPicked && isNumericCard(state.picked) && selectedCards.length >= 2;
      $("btnAdd").disabled = !canAdd;
      $("btnEnd").disabled = !hasPicked;

      if(state.phase!==PHASE.PLAY){
        $("btnClear").disabled = true;
        $("btnMatch").disabled = true;
        $("btnAdd").disabled = true;
        $("btnEnd").disabled = true;
      }
    }

    function logMsg(html){
      const item=document.createElement("div");
      item.className="logItem";
      item.innerHTML=html;
      $("log").prepend(item);
    }
    function logClear(){ $("log").innerHTML=""; }

    function maybeEndGameIfTriggered(){
      if(!state.lastPickTriggered) return;
      if(state.deck.length===0 && !state.picked && state.phase===PHASE.PLAY){
        const lastP = state.players[state.lastPickerIndex];
        if(state.middle.length){
          lastP.pile.push(...state.middle);
          logMsg(`<strong>END:</strong> ${lastP.name} picked the last Circle card and collects the remaining <b>${state.middle.length}</b> Middle card(s).`);
          state.middle=[];
        } else {
          logMsg(`<strong>END:</strong> Circle is empty and Middle is empty.`);
        }
        const results = state.players.map(p=>({name:p.name, points: totalPoints(p.pile)})).sort((a,b)=>b.points-a.points);
        const top=results[0];
        const ties=results.filter(r=>r.points===top.points);
        if(ties.length>1) logMsg(`<strong>üèÅ Game Over:</strong> Tie at <b>${top.points}</b> points between ${ties.map(t=>`<strong>${t.name}</strong>`).join(", ")}.`);
        else logMsg(`<strong>üèÅ Game Over:</strong> Winner is <strong>${top.name}</strong> with <b>${top.points}</b> points.`);
        state.phase=PHASE.ENDED;
        render();
      }
    }

    // Setup
    function setupDrawStarter(){
      const p = state.players[state.setupStarterIndex];
      const c = state.deck.pop();
      if(c.type==="joker"){
        randomInsertBack(state.deck,c);
        logMsg(`<strong>${p.name}</strong> drew a <strong>JOKER</strong> during setup ‚Äî it goes back into the Circle randomly. Draw again.`);
        render(); return;
      }
      p.pile.push(c);
      state.lastDraw=c;
      logMsg(`<strong>${p.name}</strong> starter card: <strong>${cardLabel(c)}</strong> (auto‚Äëbanked).`);
      state.setupStarterIndex += 1;
      if(state.setupStarterIndex >= state.players.length){
        state.phase=PHASE.SETUP_MIDDLE;
        logMsg(`Now seed the Middle with <strong>${state.setupMiddleTarget}</strong> cards.`);
      }
      render();
    }

    function setupSeedMiddle(){
      if(state.middle.length >= state.setupMiddleTarget) return;
      const c=state.deck.pop();
      if(c.type==="joker"){
        randomInsertBack(state.deck,c);
        logMsg(`<strong>Setup:</strong> drew a <strong>JOKER</strong> while seeding ‚Äî it goes back into the Circle randomly. Draw again.`);
        render(); return;
      }
      state.middle.push(c);
      logMsg(`<strong>Setup:</strong> Middle seeded with <strong>${cardLabel(c)}</strong> (${state.middle.length}/${state.setupMiddleTarget}).`);
      if(state.middle.length >= state.setupMiddleTarget){
        state.phase=PHASE.PLAY;
        state.turn=0;
        logMsg(`<strong>Play begins.</strong> ${currentPlayer().name} goes first.`);
      }
      render();
    }

    // Play
    function drawCard(){
      if(state.phase===PHASE.SETUP_STARTERS) return setupDrawStarter();
      if(state.phase===PHASE.SETUP_MIDDLE) return setupSeedMiddle();
      if(state.phase!==PHASE.PLAY) return;

      // If a picked card is still showing:
      // - if you've captured at least once with it, you may PICK again (same turn),
      //   but we first bank the picked card into your pile.
      // - if you haven't captured yet, you must CAPTURE or END TURN first.
      if(state.picked){
        if(state.capturedThisTurn){
          currentPlayer().pile.push(state.picked);
          logMsg(`<strong>${currentPlayer().name}</strong> banks picked card <strong>${cardLabel(state.picked)}</strong> and picks again.`);
          state.picked = null;
          state.selectedIds.clear();
          state.capturedThisTurn = false;
        } else {
          return;
        }
      }

      if(state.deck.length===0){
        maybeEndGameIfTriggered();
        return;
      }

      state.picked = state.deck.pop();
      state.lastDraw = state.picked;
      state.selectedIds.clear();
      state.capturedThisTurn = false;

      if(state.deck.length===0 && !state.lastPickTriggered){
        state.lastPickTriggered = true;
        state.lastPickerIndex = state.turn;
      }

      if(state.picked.type==="joker"){
        resolveJoker();
        return;
      }

      logMsg(`<strong>${currentPlayer().name}</strong> picked <strong>${cardLabel(state.picked)}</strong>. Select Middle cards, then CAPTURE ‚Äî or END TURN if you miss it.`);
      render();
    }

    function resolveJoker(){
      const taker=currentPlayer();
      const jokerCard=state.picked;
      const midTaken=state.middle.length;
      taker.pile.push(...state.middle); state.middle=[];
      let pilesTaken=0;
      state.players.forEach((p,idx)=>{
        if(idx!==state.turn){
          pilesTaken += p.pile.length;
          taker.pile.push(...p.pile);
          p.pile=[];
        }
      });
      taker.pile.push(jokerCard);
      state.picked=null;
      state.selectedIds.clear();
      logMsg(`<strong>${taker.name}</strong> drew a <strong>JOKER</strong> and collects <b>${pilesTaken}</b> cards from other players + <b>${midTaken}</b> Middle card(s) + the Joker. <strong>Pick again.</strong>`);
      maybeEndGameIfTriggered();
      render();
    }

    function clearSelection(){ state.selectedIds.clear(); render(); }

    // IMPORTANT RULE: after a successful capture, DO NOT end turn ‚Äî clear picked so same player can pick again.
    function captureMatch(){
      if(state.phase!==PHASE.PLAY) return;
      if(!state.picked) return;

      const selected = state.middle.filter(c=>state.selectedIds.has(c.id));
      if(selected.length===0){
        logMsg(`Select at least 1 Middle card for <strong>MATCH</strong>.`);
        return;
      }

      // All selected must match picked rank
      const ok = selected.every(c=> c.rank === state.picked.rank);
      if(!ok){
        logMsg(`‚ùå MATCH failed. Selected cards must all match the picked rank (<strong>${state.picked.rank}</strong>).`);
        return;
      }

      // Remove selected from middle
      state.middle = state.middle.filter(c=> !state.selectedIds.has(c.id));

      // Player collects selected (picked stays active until you PICK again or END TURN)
      const p = currentPlayer();
      p.pile.push(...selected);

      state.selectedIds.clear();
      state.capturedThisTurn = true;

      logMsg(`‚úÖ <strong>${p.name}</strong> MATCH captured <b>${selected.length}</b> Middle card(s). You can capture again with <strong>${cardLabel(state.picked)}</strong>, or click <strong>PICK</strong> to bank it and draw another card (same turn).`);
      render();
    }

    function captureAdd(){
      if(state.phase!==PHASE.PLAY) return;
      if(!state.picked) return;

      if(!isNumericCard(state.picked)){
        logMsg(`ADD only works when the picked card is <strong>A</strong> or <strong>2‚Äì10</strong>.`);
        return;
      }

      const selected = state.middle.filter(c=>state.selectedIds.has(c.id));
      if(selected.length < 2){
        logMsg(`Select <strong>2 or more</strong> Middle cards to <strong>ADD</strong>.`);
        return;
      }

      const target = addValue(state.picked);
      const sum = selected.reduce((a,c)=>a+addValue(c),0);

      if(sum !== target){
        logMsg(`‚ùå ADD failed. Selected sum is <b>${sum}</b> but picked is <b>${target}</b>.`);
        return;
      }

      // Success: remove selected from middle
      state.middle = state.middle.filter(c=> !state.selectedIds.has(c.id));

      // Player collects selected (picked stays active)
      const p = currentPlayer();
      p.pile.push(...selected);

      state.selectedIds.clear();
      state.capturedThisTurn = true;

      logMsg(`‚úÖ <strong>${p.name}</strong> ADD captured <b>${selected.length}</b> Middle card(s) (sum <b>${sum}</b>). You can capture again with <strong>${cardLabel(state.picked)}</strong>, or click <strong>PICK</strong> to bank it and draw another card (same turn).`);
      render();
    }

    function endTurn(){
      if(state.phase!==PHASE.PLAY) return;

      // No picked card: just advance
      if(!state.picked){
        advanceTurn();
        render();
        return;
      }

      // If player already captured at least once, ending turn banks the picked card.
      if(state.capturedThisTurn){
        currentPlayer().pile.push(state.picked);
        logMsg(`<strong>${currentPlayer().name}</strong> ends turn and banks picked card <strong>${cardLabel(state.picked)}</strong>.`);
        state.picked = null;
        state.selectedIds.clear();
        state.capturedThisTurn = false;

        if(state.lastPickTriggered){
          maybeEndGameIfTriggered();
          return;
        }

        advanceTurn();
        render();
        return;
      }

      // No capture yet: unplayed picked card goes to the Middle.
      state.middle.push(state.picked);
      logMsg(`<strong>${currentPlayer().name}</strong> ends turn ‚Äî unplayed picked card <strong>${cardLabel(state.picked)}</strong> goes to the Middle.`);

      state.picked = null;
      state.selectedIds.clear();
      state.capturedThisTurn = false;

      if(state.lastPickTriggered){
        maybeEndGameIfTriggered();
        return;
      }

      advanceTurn();
      render();
    }

    // Setup overlay UI
    function showSetup(){ const ov=$("setupOverlay"); ov.classList.add("show"); ov.setAttribute("aria-hidden","false"); rebuildNameFields(); }
    function hideSetup(){ const ov=$("setupOverlay"); ov.classList.remove("show"); ov.setAttribute("aria-hidden","true"); }
    function rebuildNameFields(){
      const count=parseInt($("playerCount").value,10);
      const box=$("nameFields"); box.innerHTML="";
      for(let i=0;i<count;i++){
        const wrap=document.createElement("div");
        wrap.className="field";
        wrap.innerHTML = `<label>Player ${i+1} name</label><input type="text" id="pname_${i}" placeholder="Player ${i+1}" />`;
        box.appendChild(wrap);
      }
    }
    $("playerCount").addEventListener("change", rebuildNameFields);
    $("btnCancelSetup").addEventListener("click", ()=> hideSetup());
    $("btnStartSetup").addEventListener("click", ()=>{
      const count=parseInt($("playerCount").value,10);
      const names=[];
      for(let i=0;i<count;i++){
        const v=($("pname_"+i).value||"").trim();
        names.push(v || `Player ${i+1}`);
      }
      hideSetup();
      initGame(names);
    });

    // Wire up
    $("circleBtn").addEventListener("click", ()=>{ if($("circleBtn").classList.contains("disabled")) return; drawCard(); });
    $("btnClear").addEventListener("click", clearSelection);
    $("btnMatch").addEventListener("click", captureMatch);
    $("btnAdd").addEventListener("click", captureAdd);
    $("btnEnd").addEventListener("click", endTurn);
    $("btnNew").addEventListener("click", showSetup);

    showSetup();
  </script>
</body>
</html>
