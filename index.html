<script>
  const N_PLAYERS = 3;
  const SETUP_MIDDLE_TARGET = 3;

  const els = {
    turnTitle: document.getElementById('turnTitle'),
    phasePill: document.getElementById('phasePill'),
    deckPill: document.getElementById('deckPill'),
    circle: document.getElementById('circle'),
    picked: document.getElementById('picked'),
    middle: document.getElementById('middle'),
    help: document.getElementById('help'),
    startGame: document.getElementById('startGame'),
    clearSel: document.getElementById('clearSel'),
    endTurn: document.getElementById('endTurn'),
    newGame: document.getElementById('newGame'),
    players: document.getElementById('players'),
    log: document.getElementById('log'),
  };

  function log(msg){
    const div = document.createElement('div');
    div.className = 'item';
    div.textContent = msg;
    els.log.prepend(div);
  }
  function setHelp(msg, type){
    els.help.classList.remove('good','bad');
    if(type) els.help.classList.add(type);
    els.help.textContent = msg;
  }

  function cardLabel(c){
    if(c.rank === 'JK') return 'JOKER';
    return String(c.rank);
  }

  // ADD uses numbers only; face cards and jokers cannot be used for ADD
  function cardAddValue(c){
    if(c.rank === 'JK') return null;
    if(c.rank === 'J' || c.rank === 'Q' || c.rank === 'K') return null;
    return c.rank; // 1..10
  }

  function buildDeck(){
    const d = [];
    for(let r=1;r<=10;r++) for(let i=0;i<4;i++) d.push({rank:r});
    for(const r of ['J','Q','K']) for(let i=0;i<4;i++) d.push({rank:r});
    d.push({rank:'JK'}); d.push({rank:'JK'});
    shuffle(d);
    return d;
  }
  function shuffle(a){
    for(let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i],a[j]] = [a[j],a[i]];
    }
  }

  let deck = [];
  let middle = [];
  let picked = null;

  // NEW: pickedCollectedOnce lets the same picked card keep capturing multiple times,
  // but the picked card itself is only collected once.
  let pickedCollectedOnce = false;

  let selectedIdxs = [];

  let players = [];
  let turn = 0;
  let phase = 'waiting'; // waiting | setup | main | finished
  let setupPlaced = 0;

  function initPlayers(){
    players = [];
    for(let i=0;i<N_PLAYERS;i++) players.push({ name:`Player ${i+1}`, pile:[] });
  }

  function enableCircle(enabled){
    els.circle.classList.toggle('disabled', !enabled);
  }

  function renderTop(){
    els.turnTitle.textContent = `Turn: ${players[turn].name}`;
    els.phasePill.textContent = `Phase: ${phase[0].toUpperCase()+phase.slice(1)}`;
    els.deckPill.textContent = `Circle: ${deck.length}`;
  }

  function renderPlayers(){
    els.players.innerHTML = '';
    players.forEach((p,i)=>{
      const div = document.createElement('div');
      div.className = 'item';
      div.innerHTML = `
        <div class="k">${p.name}${i===turn ? ' (turn)' : ''}</div>
        <div class="v">Cards collected: ${p.pile.length}</div>
        <div class="k">End score is calculated when game ends</div>
      `;
      els.players.appendChild(div);
    });
  }

  function renderPicked(){
    const mini1 = els.picked.querySelector('.mini');
    const big = els.picked.querySelector('.big');
    const mini2 = els.picked.querySelector('.mini.br');
    if(!picked){
      mini1.textContent='‚Äî'; big.textContent='‚Äî'; mini2.textContent='‚Äî';
      els.picked.classList.remove('sel');
    } else {
      const lbl = cardLabel(picked);
      mini1.textContent = lbl;
      big.textContent = (lbl==='JOKER') ? 'üÉè' : lbl;
      mini2.textContent = lbl;
      // If picked is still active, highlight it slightly
      if(pickedCollectedOnce) els.picked.classList.add('sel');
      else els.picked.classList.remove('sel');
    }
  }

  function renderMiddle(){
    els.middle.innerHTML = '';
    middle.forEach((c,idx)=>{
      const el = document.createElement('div');
      el.className = 'card';
      if(selectedIdxs.includes(idx)) el.classList.add('sel');
      const lbl = cardLabel(c);
      el.innerHTML = `
        <div class="mini">${lbl}</div>
        <div class="big">${lbl==='JOKER'?'üÉè':lbl}</div>
        <div class="mini br">${lbl}</div>
      `;
      el.addEventListener('click', ()=>onMiddleClick(idx));
      els.middle.appendChild(el);
    });
  }

  function clearSelection(){
    selectedIdxs = [];
    renderMiddle();
  }

  function nextTurn(){
    turn = (turn + 1) % N_PLAYERS;
    picked = null;
    pickedCollectedOnce = false;
    clearSelection();
    renderTop(); renderPlayers(); renderPicked();

    if(phase === 'setup'){
      setHelp(`${players[turn].name}: click the Circle to place 1 card into the Middle (no Jokers in setup).`, null);
    } else if(phase === 'main'){
      setHelp(`${players[turn].name}: click the Circle to pick a card.`, null);
    }
  }

  // Can any capture still be done with current picked (used after each capture)
  function hasAnyCaptureWithCurrentPicked(){
    if(!picked) return false;
    if(picked.rank === 'JK') return true;

    // MATCH
    if(middle.some(m => cardLabel(m) === cardLabel(picked))) return true;

    // ADD only if picked is number
    const target = cardAddValue(picked);
    if(target == null) return false;

    for(let i=0;i<middle.length;i++){
      for(let j=i+1;j<middle.length;j++){
        const a = cardAddValue(middle[i]);
        const b = cardAddValue(middle[j]);
        if(a == null || b == null) continue;
        if(a + b === target) return true;
      }
    }
    return false;
  }

  function ensurePickedCollectedOnce(){
    if(!pickedCollectedOnce){
      players[turn].pile.push(picked);
      pickedCollectedOnce = true;
      renderPlayers();
      renderPicked();
    }
  }

  function handleJokerPickup(wasLastPick){
    const picker = players[turn];

    players.forEach((p,i)=>{
      if(i!==turn && p.pile.length){
        picker.pile.push(...p.pile);
        p.pile = [];
      }
    });

    if(middle.length){
      picker.pile.push(...middle);
      middle = [];
    }

    picker.pile.push(picked);

    log(`${picker.name} picked a JOKER! Collected everyone‚Äôs cards + all Middle cards.`);
    setHelp(`üÉè JOKER! ${picker.name} collected everyone‚Äôs cards + the Middle. Pick again.`, 'good');

    picked = null;
    pickedCollectedOnce = false;
    clearSelection();
    renderPlayers(); renderMiddle(); renderPicked(); renderTop();

    if(wasLastPick) endGame(turn);
  }

  function scorePile(pile){
    let pts = 0;
    for(const c of pile){
      if(c.rank === 'JK') pts += 1;
      else if(c.rank === 'J' || c.rank === 'Q' || c.rank === 'K') pts += 10;
      else pts += 1;
    }
    return pts;
  }

  function endGame(lastPickerIndex){
    const lastPicker = players[lastPickerIndex];

    if(middle.length){
      lastPicker.pile.push(...middle);
      log(`${lastPicker.name} picked the last Circle card and takes all remaining Middle cards (${middle.length}).`);
      middle = [];
    }

    const scores = players.map(p=>scorePile(p.pile));
    const max = Math.max(...scores);
    const winners = players.map((p,i)=>({name:p.name, score:scores[i]})).filter(x=>x.score===max);

    renderMiddle(); renderPlayers();
    log(`GAME OVER ‚Äî ${players.map((p,i)=>`${p.name}: ${scores[i]} pts`).join(' | ')}`);

    if(winners.length===1) setHelp(`üèÅ GAME OVER! Winner: ${winners[0].name} with ${winners[0].score} points.`, 'good');
    else setHelp(`üèÅ GAME OVER! Tie: ${winners.map(w=>w.name).join(', ')} with ${max} points.`, 'good');

    phase = 'finished';
    enableCircle(false);
    renderTop();
  }

  function drawNonJokerForSetup(){
    while(deck.length){
      const c = deck.pop();
      if(c.rank !== 'JK') return c;
      deck.unshift(c);
      shuffle(deck);
      log('Setup draw hit a JOKER ‚Äî put back and redrawn (Jokers not allowed in setup).');
    }
    return null;
  }

  function onCircleClick(){
    if(phase==='waiting'){ setHelp('Click START GAME first.', 'bad'); return; }
    if(phase==='finished'){ setHelp('Game is over. Click New Game to play again.', null); return; }
    if(deck.length===0){ setHelp('Circle is empty.', 'bad'); return; }

    // NEW: You cannot draw a new card while a picked card is still active.
    if(phase==='main' && picked){
      setHelp('Finish using your picked card first (match/add as much as you can), then click the picked card to move on.', 'bad');
      return;
    }

    const currentPlayer = players[turn];

    if(phase==='setup'){
      const c = drawNonJokerForSetup();
      if(!c){ setHelp('No cards left. Something went wrong.', 'bad'); return; }
      middle.push(c);
      setupPlaced++;
      log(`${currentPlayer.name} placed ${cardLabel(c)} into the Middle (setup).`);
      renderTop(); renderMiddle(); renderPlayers();

      if(setupPlaced >= SETUP_MIDDLE_TARGET){
        phase = 'main';
        picked = null;
        pickedCollectedOnce = false;
        clearSelection();
        renderTop();
        setHelp(`Setup complete. ${players[turn].name}: click the Circle to pick a card.`, null);
        log('Setup complete. Main phase begins.');
        return;
      }
      nextTurn();
      return;
    }

    // MAIN pick
    const card = deck.pop();
    const wasLastPick = (deck.length === 0);
    picked = card;
    pickedCollectedOnce = false;
    renderPicked(); renderTop();

    if(picked.rank === 'JK'){
      handleJokerPickup(wasLastPick);
      return;
    }

    // If no capture possible at all, picked goes to Middle and turn ends
    if(!hasAnyCaptureWithCurrentPicked()){
      middle.push(picked);
      log(`${currentPlayer.name} picked ${cardLabel(picked)} ‚Äî no add/match. Card goes to Middle. Turn ends.`);
      setHelp(`‚ùå No add/match. Card goes to the Middle. Turn ends.`, 'bad');

      picked = null;
      pickedCollectedOnce = false;
      clearSelection();
      renderPicked(); renderMiddle(); renderPlayers(); renderTop();

      if(wasLastPick){ endGame(turn); return; }
      setTimeout(nextTurn, 350);
      return;
    }

    // If capture is possible, keep picked active until player is done capturing
    const pickedIsNumber = (cardAddValue(picked) != null);
    setHelp(
      pickedIsNumber
        ? `Picked ${cardLabel(picked)}. You can MATCH (same) and/or ADD pairs. Capture as many as you can. Click the picked card when done.`
        : `Picked ${cardLabel(picked)}. MATCH only. Capture as many matches as you can. Click the picked card when done.`,
      null
    );

    if(wasLastPick){
      log(`${currentPlayer.name} picked the LAST Circle card (${cardLabel(picked)}). Finish your captures; game will end after you're done.`);
    }
  }

  // NEW: click picked card to finish this picked-card phase
  function onPickedClick(){
    if(phase !== 'main') return;
    if(!picked) return;

    // If they never captured anything, they shouldn't be able to "finish" early
    // because they must play if possible. But since we want teaching,
    // we‚Äôll allow finishing only if no more captures exist.
    if(hasAnyCaptureWithCurrentPicked()){
      setHelp('You still have a match/add available. In this game, if you miss it and move on, you can‚Äôt go back.', 'bad');
      return;
    }

    // Done with this picked card: clear it and allow picking again.
    picked = null;
    pickedCollectedOnce = false;
    clearSelection();
    renderPicked(); renderMiddle(); renderPlayers(); renderTop();

    // If deck ended earlier, end game now (last picker takes remaining middle)
    if(deck.length === 0){
      endGame(turn);
      return;
    }

    setHelp(`${players[turn].name}: click the Circle to pick again.`, null);
  }

  function onMiddleClick(idx){
    if(phase!=='main') return;
    if(!picked){ setHelp('Pick a card from the Circle first.', 'bad'); return; }
    if(picked.rank==='JK') return;

    const pickedLbl = cardLabel(picked);

    // If they click a matching card, capture it immediately (no selection needed)
    const clicked = middle[idx];
    if(cardLabel(clicked) === pickedLbl){
      ensurePickedCollectedOnce();
      players[turn].pile.push(clicked);

      log(`${players[turn].name} MATCHED ${pickedLbl} and captured 1 Middle card (picked kept active).`);
      setHelp(`‚úÖ MATCH captured. Keep going ‚Äî capture more with ${pickedLbl} if you can.`, 'good');

      middle.splice(idx, 1);
      clearSelection();
      renderPlayers(); renderMiddle(); renderPicked(); renderTop();

      if(!hasAnyCaptureWithCurrentPicked()){
        setHelp(`No more captures for ${pickedLbl}. Click the picked card to move on.`, null);
      }
      return;
    }

    // Otherwise they are trying ADD: select up to 2 cards
    if(selectedIdxs.includes(idx)) selectedIdxs = selectedIdxs.filter(x=>x!==idx);
    else {
      if(selectedIdxs.length>=2){ setHelp('Select at most 2 Middle cards for ADD.', 'bad'); return; }
      selectedIdxs.push(idx);
    }
    renderMiddle();

    if(selectedIdxs.length === 2){
      const aCard = middle[selectedIdxs[0]];
      const bCard = middle[selectedIdxs[1]];

      const target = cardAddValue(picked);
      const a = cardAddValue(aCard);
      const b = cardAddValue(bCard);

      if(target == null || a == null || b == null){
        setHelp('‚ùå ADD uses NUMBER cards only (1‚Äì10). Clear selection and try again.', 'bad');
        return;
      }

      if(a + b === target){
        ensurePickedCollectedOnce();

        players[turn].pile.push(aCard, bCard);
        log(`${players[turn].name} ADDED two cards to make ${cardLabel(picked)} and captured them (picked kept active).`);
        setHelp('‚úÖ ADD captured. Keep going ‚Äî capture more pairs if you can.', 'good');

        const i1 = Math.max(selectedIdxs[0], selectedIdxs[1]);
        const i2 = Math.min(selectedIdxs[0], selectedIdxs[1]);
        middle.splice(i1, 1);
        middle.splice(i2, 1);

        selectedIdxs = [];
        renderPlayers(); renderMiddle(); renderPicked(); renderTop();

        if(!hasAnyCaptureWithCurrentPicked()){
          setHelp(`No more captures for ${cardLabel(picked)}. Click the picked card to move on.`, null);
        }
        return;
      }

      setHelp('‚ùå Not a valid ADD. Clear selection and try again.', 'bad');
      return;
    }
  }

  function onEndTurn(){
    if(phase!=='main'){ setHelp('End Turn is only for the main phase.', null); return; }
    if(phase==='finished') return;

    // Can't end turn while picked still has a possible capture
    if(picked && hasAnyCaptureWithCurrentPicked()){
      setHelp("You still have an add/match available. If you miss it and end your turn, you can't go back ‚Äî but you also can't end while a move exists.", 'bad');
      return;
    }

    picked = null;
    pickedCollectedOnce = false;
    clearSelection();
    renderPicked();
    log(`${players[turn].name} ended their turn.`);

    if(deck.length===0){ endGame(turn); return; }
    nextTurn();
  }

  function startGame(){
    if(phase!=='waiting') return;
    phase = 'setup';
    setupPlaced = 0;
    middle = [];
    picked = null;
    pickedCollectedOnce = false;
    selectedIdxs = [];

    enableCircle(true);
    renderTop(); renderPlayers(); renderPicked(); renderMiddle();

    setHelp(`${players[turn].name}: click the Circle to place 1 card into the Middle (no Jokers in setup).`, null);
    log('START GAME pressed. Setup phase begins.');
  }

  function newGame(){
    deck = buildDeck();
    middle = [];
    picked = null;
    pickedCollectedOnce = false;
    selectedIdxs = [];
    turn = 0;
    phase = 'waiting';
    setupPlaced = 0;
    els.log.innerHTML = '';

    initPlayers();
    enableCircle(false);
    renderTop(); renderPlayers(); renderPicked(); renderMiddle();
    setHelp('Click START GAME to begin.', null);
    log('New game loaded. Waiting to start.');
  }

  // events
  els.circle.addEventListener('click', onCircleClick);
  els.picked.addEventListener('click', onPickedClick); // NEW
  els.startGame.addEventListener('click', startGame);
  els.clearSel.addEventListener('click', ()=>{ clearSelection(); setHelp('Selection cleared.', null); });
  els.endTurn.addEventListener('click', onEndTurn);
  els.newGame.addEventListener('click', newGame);

  // init
  deck = buildDeck();
  initPlayers();
  enableCircle(false);
  renderTop(); renderPlayers(); renderPicked(); renderMiddle();
</script>
